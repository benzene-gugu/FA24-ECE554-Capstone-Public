import m_rv32::*;
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
import SDRAM_params::*; // Import the SDRAM parameters
module Doomed(

		//////////// ADC //////////
		output                      ADC_CONVST,
		output                      ADC_DIN,
		input                       ADC_DOUT,
		output                      ADC_SCLK,

		//////////// Audio //////////
		input                       AUD_ADCDAT,
		inout                       AUD_ADCLRCK,
		inout                       AUD_BCLK,
		output                      AUD_DACDAT,
		inout                       AUD_DACLRCK,
		output                      AUD_XCK,

		//////////// CLOCK //////////
		input                       REF_CLK,

		//////////// SDRAM //////////
		output          [12:0]      DRAM_ADDR,
		output           [1:0]      DRAM_BA,
		output                      DRAM_CAS_N,
		output                      DRAM_CKE,
		output                      DRAM_CLK,
		output                      DRAM_CS_N,
		inout           [15:0]      DRAM_DQ,
		output                      DRAM_LDQM,
		output                      DRAM_RAS_N,
		output                      DRAM_UDQM,
		output                      DRAM_WE_N,

		//////////// I2C for Audio and Video-In //////////
		output                      FPGA_I2C_SCLK,
		inout                       FPGA_I2C_SDAT,

		//////////// SEG7 //////////
		output           [6:0]      HEX0,
		output           [6:0]      HEX1,
		output           [6:0]      HEX2,
		output           [6:0]      HEX3,
		output           [6:0]      HEX4,
		output           [6:0]      HEX5,

		//////////// IR //////////
		input                       IRDA_RXD,
		output                      IRDA_TXD,

		//////////// KEY //////////
		input            [3:1]      KEY, //KEY 0 for reset
		input                       RST_n,

		//////////// LED //////////
		output           [9:0]      LEDR,

		//////////// PS2 //////////
		inout                       PS2_CLK,
		inout                       PS2_CLK2,
		inout                       PS2_DAT,
		inout                       PS2_DAT2,

		//////////// SW //////////
		input            [9:0]      SW,

		//////////// VGA //////////
		output                      VGA_BLANK_N,
		output           [7:0]      VGA_B,
		output                      VGA_CLK,
		output           [7:0]      VGA_G,
		output                      VGA_HS,
		output           [7:0]      VGA_R,
		output                      VGA_SYNC_N,
		output                      VGA_VS,

		//////////// SPI //////////
		output                      SS0_n,
		output                      SCLK0,
		inout            [3:0]      MOSI0,

		input                       RX,
		output                      TX
	);

	wire MISO, MOSI;

	assign MOSI0[0] = MOSI;
	assign MISO = MOSI0[1];
	assign MOSI0[2] = 1'b1; // WP_n
	assign MOSI0[3] = 1'b1; // HOLD_n

	logic clk, rst_n, pll_locked, clk100m;

	logic peri_w, peri_r;
	logic [31:0] peri_rdata, peri_wdata;
	logic [27:0] peri_addr;
	logic [12:0] human_inputs_deb, human_inputs,human_inputs_int;

	//VGA related signals
	wire [9:0] xpix;                    // current X coordinate of VGA
	wire [8:0] ypix;                    // current Y coordinate of VGA

	// SDRAM side signals
    logic [23:0] addr_SDRAM; // Address signal for the SDRAM
    logic [31:0] data_write_SDRAM; // Data write for the SDRAM
    logic write_SDRAM; // Write signal for the SDRAM
    logic request_SDRAM; // Request signal for the SDRAM
    logic ack_SDRAM; // Acknowledge signal for the SDRAM
    logic valid_SDRAM; // Valid signal indicating that the read/write data is valid
    logic [31:0] data_read_SDRAM; // Data read for the SDRAM

	debouncer debun[12:0](.clk, .rst_n, .in(human_inputs), .out(human_inputs_deb));

	//===================
	//50MHz, 25MHz VGA and 100MHz DRAM PLL
	//===================
	PLLsys_vga iPLL(.refclk(REF_CLK), .rst(~RST_n), .outclk_0(clk), .outclk_1(VGA_CLK), .outclk_2(clk100m), .outclk_3(DRAM_CLK), .locked(pll_locked));
	//===================
	//reset
	//===================
	rst_synch iRST(.clk(clk),.RST_n(RST_n), .pll_locked, .rst_n(rst_n));
	//double-flop human inputs
	always_ff @(posedge clk, negedge rst_n)
		if(~rst_n)begin
			human_inputs <= '0;
			human_inputs_int <= '0;
		end
		else begin
			human_inputs <= human_inputs_int;
			human_inputs_int <= {~KEY[3:1], SW[9:0]};
		end
		
	//===================
	//main CPU
	//===================
	top_proc iCPU(.rst_n, .clk, .peri_r, .peri_w, .peri_addr, .peri_wdata, .peri_rdata, .led(),
	              .clk100m, .addr_SDRAM, .request_SDRAM, .ack_SDRAM, .write_SDRAM, .data_read_SDRAM, .data_write_SDRAM, .valid_SDRAM);
	/*
	sdram_interface iSDRAM(.clk(clk100m), .re(re_SDRAM), .we(we_SDRAM), .addr(addr_SDRAM), .data_read(data_read_SDRAM), 
	                       .data_write(data_write_SDRAM), .valid(valid_SDRAM), .done(done_SDRAM), 
						   .CLK(DRAM_CLK), .SA(DRAM_ADDR), .BA(DRAM_BA), .CS_N(DRAM_CS_N), .CKE(DRAM_CKE), .RAS_N(DRAM_RAS_N), 
						   .CAS_N(DRAM_CAS_N), .WE_N(DRAM_WE_N), .DQM({DRAM_UDQM, DRAM_LDQM}), .DQ(DRAM_DQ));
	*/
	sdram iSDRAM(.reset(~rst_n), .clk(clk100m), .addr(addr_SDRAM), .data(data_write_SDRAM), .we(write_SDRAM), .req(request_SDRAM), .ack(ack_SDRAM), .valid(valid_SDRAM), .q(data_read_SDRAM), 
	             .sdram_a(DRAM_ADDR), .sdram_ba(DRAM_BA), .sdram_dq(DRAM_DQ), .sdram_cke(DRAM_CKE), .sdram_cs_n(DRAM_CS_N), 
				 .sdram_ras_n(DRAM_RAS_N), .sdram_cas_n(DRAM_CAS_N), .sdram_we_n(DRAM_WE_N), .sdram_dqml(DRAM_LDQM), .sdram_dqmh(DRAM_UDQM));
	//===================
	//peripheral mux
	//===================
	logic w_led, iocs_n, iorw_n, uartioaddr;
	logic vram_we;
	logic [23:0] vram_wrdata, vram_wdata, vga_rdata;
	logic [18:0] vga_raddr;
	logic [31:0] uart_datain, uart_dataout;
	logic spi_re, spi_we;
	logic [3:0] spi_addr;
	logic [31:0] spi_rdata;
	always_comb begin
		w_led = 0;

		uart_datain = 'x;
		iocs_n = 1;
		iorw_n = ~peri_w; //don't care before cs is asserted
		uartioaddr = 1;

		spi_re = 1'b0;
		spi_we = 1'b0;
		spi_addr = 4'h0;

		vram_we = 0;
		vram_wdata = 0;

		peri_rdata = 0;
		//if(peri_r | peri_w)
		case(peri_addr) //default to read data
			//========= complex case statement is not supported by quartus
			//========
			//LED & human input
			//========
			MMAP_LED:
				w_led = peri_w;
			MMAP_HIN:
				peri_rdata = {19'b0, human_inputs_deb};
			//========
			//UART
			//========
			MMAP_UARTCTL: begin// cs only when addr is right and there is r/w
				iocs_n = ~(peri_r | peri_w);
				uartioaddr = 1;
				if(peri_w) uart_datain = peri_wdata;
				else peri_rdata = uart_dataout;
			end
			MMAP_UART_TR: begin //cs only when addr is right and there is r/w
				iocs_n = ~(peri_r | peri_w);
				uartioaddr = 0;
				if(peri_w) uart_datain = peri_wdata;
				else peri_rdata = uart_dataout;
			end

			default: begin
				//========
				// SPI
				//========
				// SPI is special because it has an address range of 16 bytes (i.e. 4 registers)
				if (peri_addr[27:4] == MMAP_SPI[27:4]) begin
					spi_re = peri_r;
					spi_we = peri_w;
					spi_addr = peri_addr[3:0];
					peri_rdata = spi_rdata;
				end

				//========
				//VGA
				//========
				else if(peri_addr >= MMAP_FRAMEBF && peri_addr < MMAP_FRAMEBF+SIZE_FRAMEBF)begin
					vram_we = peri_w;
					if(peri_w)
						vram_wdata = peri_wdata;
					else
						peri_rdata = vram_wrdata;
				end
			end
		endcase
	end
	logic [9:0] ledout;
	assign LEDR = ledout;
	peripheral_led iLED(.rst_n, .clk, .LED(ledout), .wdata(peri_wdata), .w_led);
	peripheral_spart iUART(
		.clk, .rst_n,
		.iocs_n, .iorw_n,
		.tx_q_full(), .rx_q_empty(),
		.ioaddr(uartioaddr), .dataout(uart_dataout), .datain(uart_datain),
		.TX, .RX
	);

	peripheral_SPI iSPI(
		.clk, .rst_n,
		.re(spi_re), .we(spi_we),
		.addr(spi_addr),
		.wdata(peri_wdata), .rdata(spi_rdata),

		.SS_n(SS0_n), .SCLK(SCLK0), .MOSI, .MISO
	);

	/////////////////////////////////////
	// VGA Module
	///////////////////////////////////
	//Instantiate 6-bit video memory
	peripheral_videoMem iVRAM(.clk(clk),.we(vram_we),.waddr(peri_addr[20:2]),.wdata(vram_wdata), .wrdata(vram_wrdata), .raddr(vga_raddr),.rdata(vga_rdata));
	//Instantiate VGA Timing Generator
	peripheral_VGA_timing iVGATM(.clk25MHz(VGA_CLK), .rst_n(rst_n), .VGA_BLANK_N(VGA_BLANK_N),
		.VGA_HS(VGA_HS),.VGA_SYNC_N(VGA_SYNC_N), .VGA_VS(VGA_VS),
		.xpix(xpix), .ypix(ypix), .addr_lead(vga_raddr));
	//output to VGA pins
	assign VGA_R = vga_rdata[23:16];
	assign VGA_G = vga_rdata[15:8];
	assign VGA_B = vga_rdata[7:0];

endmodule
